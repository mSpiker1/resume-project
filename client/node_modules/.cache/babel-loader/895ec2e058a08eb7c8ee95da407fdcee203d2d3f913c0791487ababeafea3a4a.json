{"ast":null,"code":"export function makePixelPerfect(elem) {\n  if (elem instanceof HTMLImageElement && !elem.complete) {\n    elem.decode().then(() => {\n      makePixelPerfect(elem);\n    });\n    return;\n  }\n  const origWidth = elem.naturalWidth || elem.width; // TODO, handle canvas, video?\n  const origHeight = elem.naturalHeight || elem.height;\n  const options = {\n    scale: 1\n  };\n  {\n    const q = elem.dataset.pixelPerfect;\n    if (q) {\n      if (q.includes('=')) {\n        Object.assign(options, Object.fromEntries(new URLSearchParams(elem.dataset.pixelPerfect || '').entries()));\n      } else {\n        const scale = parseInt(q);\n        if (scale > 0) {\n          options.scale = scale;\n        }\n      }\n    } else {\n      // guess the scale based on the natural size vs the CSS size\n      const cssWidth = Math.round(parseFloat(getComputedStyle(elem).width));\n      const scale = Math.round(Math.max(1, cssWidth / origWidth));\n      if (scale > 0) {\n        elem.dataset.pixelPerfect = scale;\n        options.scale = scale;\n      }\n    }\n  }\n  let scale = options.scale;\n  if (scale % 1 !== 0) {\n    console.warn('scale must be an integer value');\n  }\n  const px = v => `${v}px`;\n  let good;\n  do {\n    const desiredWidth = origWidth * scale;\n    const targetWidth = desiredWidth * devicePixelRatio;\n    const mult = Math.max(1, Math.round(targetWidth / origWidth));\n    const cssWidth = origWidth * mult / devicePixelRatio;\n    const cssHeight = origHeight * mult / devicePixelRatio;\n    elem.style.width = px(cssWidth);\n    elem.style.height = px(cssHeight);\n\n    // get the size it will actually be displayed. If smaller than we asked,\n    // try the next smallest integer size\n    const {\n      width,\n      height\n    } = elem.getBoundingClientRect();\n    const diffX = Math.abs(cssWidth - width);\n    const diffY = Math.abs(cssHeight - height);\n    good = diffX < 1 && diffY < 1;\n    scale -= 1;\n  } while (scale > 0 && !good);\n}\nfunction makeAllPixelPerfect() {\n  document.querySelectorAll(\".pixel-perfect\").forEach(makePixelPerfect);\n}\nwindow.addEventListener('resize', makeAllPixelPerfect);\nmakeAllPixelPerfect();","map":{"version":3,"names":["makePixelPerfect","elem","HTMLImageElement","complete","decode","then","origWidth","naturalWidth","width","origHeight","naturalHeight","height","options","scale","q","dataset","pixelPerfect","includes","Object","assign","fromEntries","URLSearchParams","entries","parseInt","cssWidth","Math","round","parseFloat","getComputedStyle","max","console","warn","px","v","good","desiredWidth","targetWidth","devicePixelRatio","mult","cssHeight","style","getBoundingClientRect","diffX","abs","diffY","makeAllPixelPerfect","document","querySelectorAll","forEach","window","addEventListener"],"sources":["D:/Personal_Projects/resume-project/src/utils/pixel-perfect.js"],"sourcesContent":["export function makePixelPerfect(elem) {\r\n    if (elem instanceof HTMLImageElement && !elem.complete) {\r\n      elem.decode()\r\n        .then(() => {\r\n          makePixelPerfect(elem);\r\n         });\r\n      return;\r\n    }\r\n    const origWidth = elem.naturalWidth || elem.width; // TODO, handle canvas, video?\r\n    const origHeight = elem.naturalHeight || elem.height;\r\n    const options = {\r\n      scale: 1,\r\n    };\r\n  \r\n    {\r\n      const q = elem.dataset.pixelPerfect;\r\n      if (q) {\r\n        if (q.includes('=')) {\r\n          Object.assign(options, Object.fromEntries(new URLSearchParams(elem.dataset.pixelPerfect || '').entries()));\r\n        } else {\r\n          const scale = parseInt(q);\r\n          if (scale > 0) {\r\n            options.scale = scale;\r\n          }\r\n        }\r\n      } else {\r\n        // guess the scale based on the natural size vs the CSS size\r\n        const cssWidth = Math.round(parseFloat(getComputedStyle(elem).width));\r\n        const scale = Math.round(Math.max(1, cssWidth / origWidth));\r\n        if (scale > 0) {\r\n          elem.dataset.pixelPerfect = scale;\r\n          options.scale = scale;\r\n        }\r\n      }\r\n  \r\n    }\r\n  \r\n    let scale = options.scale\r\n    if (scale % 1 !== 0) {\r\n      console.warn('scale must be an integer value');\r\n    }\r\n  \r\n    const px = v => `${v}px`;\r\n  \r\n    let good;\r\n    do {\r\n      const desiredWidth = origWidth * scale;\r\n      const targetWidth = desiredWidth * devicePixelRatio;\r\n      const mult = Math.max(1, Math.round(targetWidth / origWidth));\r\n      const cssWidth = origWidth * mult / devicePixelRatio\r\n      const cssHeight = origHeight * mult / devicePixelRatio\r\n      elem.style.width = px(cssWidth);\r\n      elem.style.height = px(cssHeight);\r\n  \r\n      // get the size it will actually be displayed. If smaller than we asked,\r\n      // try the next smallest integer size\r\n      const {width, height} = elem.getBoundingClientRect();\r\n      const diffX = Math.abs(cssWidth - width);\r\n      const diffY = Math.abs(cssHeight - height);\r\n      good = diffX < 1 && diffY < 1;\r\n      scale -= 1;\r\n    } while (scale > 0 && !good);\r\n  \r\n  }\r\n  \r\n  function makeAllPixelPerfect() {\r\n    document.querySelectorAll(\".pixel-perfect\").forEach(makePixelPerfect);\r\n  }\r\n  window.addEventListener('resize', makeAllPixelPerfect);\r\n  makeAllPixelPerfect();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}